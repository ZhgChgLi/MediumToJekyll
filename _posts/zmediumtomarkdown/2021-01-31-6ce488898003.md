---
title: AVPlayer 實踐本地 Cache 功能大全
author: ZhgChgLi
date: 2021-01-31T10:41:42.622+0000
last_modified_at: 2021-02-24T01:44:04.173+0000
categories: ZRealm Dev.
tags: [ios,ios-app-development,cache,avplayer,music-player-app]
description: AVPlayer/AVQueuePlayer with AVURLAsset 實作 AVAssetResourceLoaderDelegate
image:
  path: assets/6ce488898003/1*lAGpCiT80GFIQ2adYworVw.jpeg
render_with_liquid: false
---

### AVPlayer 實踐本地 Cache 功能大全

AVPlayer/AVQueuePlayer with AVURLAsset 實作 AVAssetResourceLoaderDelegate


![Photo by [Tyler Lastovich](https://unsplash.com/@lastly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/6ce488898003/1*lAGpCiT80GFIQ2adYworVw.jpeg)

Photo by [Tyler Lastovich](https://unsplash.com/@lastly?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### 前言

既上一篇「 [iOS HLS Cache 實踐方法探究之旅](../d796bf8e661e/) 」後已過了大半年，團隊還是一直想要實現邊播邊 Cache 功能因為對成本的影響極大；我們是音樂串流平台，如果每次播放同樣的歌曲都要重新拿整個檔案，對我們或對非吃到飽的使用者來說都很傷流量，雖然音樂檔案頂多幾 MB，但積沙成塔都是錢！

另外因為 Android 那邊已經有實作邊播邊 Cache 的功能了，之前有比較過花費，Android 端上線後明顯節省了許多流量；相對更多使用者的 iOS 應該能有更好的節流體現。

根據 [上一篇](../d796bf8e661e/) 的經驗，如果我們要繼續使用 HLS \( \.m3u8/\.ts\) 來達成目的；事情將會變得非常複雜甚至無法達成；我們退而求其次退回去使用 mp3 檔，這樣就能直接使用 `AVAssetResourceLoaderDelegate` 進行實作。
### 目標
- 播放過的音樂會在本地產生 Cache 備份
- 播放音樂時先檢查本地有無 Cache 讀取，有則不再重伺服器要檔案
- 可設 Cache 策略；上限總容量，超過時開始刪除最舊的 Cache 檔案
- 不干涉原本 AVPlayer 播放機制
（不然最快的方法就是自己先用 URLSession 把 mp3 載下來塞給 AVPlayer，但這樣就失去原本能播到哪載到哪的功能，使用者需要等待更長時間＆更消耗流量）

### 前導知識 \(1\)— HTTP/1\.1 Range 範圍請求、Connection Keep\-Alive
#### HTTP/1\.1 Range 範圍請求

首先我們要先了解在播放影片、音樂時是怎麼跟伺服器要求資料的；一般來說影片、音樂檔案都很大，不可能等到全部拿完才開始播放常見的是播到哪拿到了，只要有正在播放區段的資料就能運作。

要達到這個功能的方法就是透過 HTTP/1\.1 Range 只返回指定資料字節範圍的資料，例如指定 0–100 就只返回 0–100 這 100 bytes 大小的資料；透過這個方法，可以依序分段取得資料，然後再彙整再一起成完整的檔案；這個方法也能運用在檔案下載續傳功能上。
#### 如何應用？

我們會先使用 HEAD 去看 Response Header 了解到伺服器是否支援 Range 範圍請求、資源總長度、檔案類型：
```
curl -i -X HEAD http://zhgchg.li/music.mp3
```

**使用 HEAD 我們能從 Response Header 得到以下資訊：**
- **Accept\-Ranges: bytes** 代表伺服器支援 Range 範圍請求
如果沒有 Response 這個值或是是 Accept\-Ranges: none 都代表不支援
- **Content\-Length:** 資源總長度，我們要知道總長度才能去分段要資料。
- **Content\-Type:** 檔案類型，AVPlayer 播放時需要知道的資訊。


但有時我們也會使用 GET `Range: bytes=0–1` ，意思是我要求 0–1 範圍的資料但實際我根本不 Care 0–1是什麼內容，我只是要看 Response Header 的資訊； **原生 AVPlayer 就是使用 GET 去看，所以本篇也照舊使用** 。


> _但比較建議使用 HEAD 去看，一方法比較正確，另一方面萬一伺服器不支援 Range 功能；用 GET 去摸就會變強迫下載完整檔案。_ 




```
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–1"
```

**使用 GET 我們能從 Response Header 得到以下資訊：**
- **Accept\-Ranges: bytes** 代表伺服器支援 Range 範圍請求
如果沒有 Response 這個值或是是 Accept\-Ranges: none 都代表不支援
- **Content\-Range: bytes 0–1/資源總長度** ，「/」後的數字及資源總長度，我們要知道總長度才能去分段要資料。
- **Content\-Type:** 檔案類型，AVPlayer 播放時需要知道的資訊。



![](/assets/6ce488898003/1*IP55kaFB3NES3QWZ7Mf-aw.jpeg)


**知道伺服器支援 Range 範圍請求後，就能分段發起範圍請求：**
```
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–100"
```

**伺服器會返回 206 Partial Content：**
```
Content-Range: bytes 0-100/總長度
Content-Length: 100
...
(binary content)
```

這時我們就得到 Range 0–100 的 Data，可再繼續發新請求拿 Range 100–200\. \.200–300…到結束。

如果拿的 Range 超過資源總長度會返回 416 Range Not Satisfiable。

另外，想拿完整檔案資料除了可以請求 Range 0\-總長度，也可以使用 0\- 方式即可：
```
curl -i -X GET http://zhgchg.li/music.mp3 -H "Range: bytes=0–"
```

其他還可以同個請求要求多個 Range 資料及下條件式子，但我們用不到，詳情可 [參考這](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests){:target="_blank"} 。
#### Connection Keep\-Alive

http 1\.1 預設是開啟狀態， **此特性能實時取得已下載的資料** ，例如檔案 5 mb，能 16 kb、16 kb、16 kb… 的取得，不用等到 5mb 都好才給你。
```
Connection: Keey-Alive
```
#### **_如果發現伺服器不支援 Range、_** Keep\-Alive **_？_**


> _那也不用搞這麼多了，直接自己用 URLSession 下載完 mp3 檔案塞給播放器就好…\.但這不是我們要的結果，可以請後端幫忙修改伺服器設定。_ 




### 前導知識 \(2\) — AVPlayer 原生是如何處理 AVURLAsset 資源？


![](/assets/6ce488898003/1*iLE51pGNDl_5Jwp8cTM6HQ.jpeg)


當我們使用 AVURLAsset init with URL 資源並賦予給 AVPlayer/AVQueuePlayer 開始播放之後，同上所述，首先會用 GET Range 0–1 去取得是否支援 Range 範圍請求、資源總長度、檔案類型這三個資訊。

有了檔案資訊後，會再發起第二次請求，請求從 0\-總長度 的資料。


> _⚠️ **AVPlayer 會請求從 0\-總長度 的資料，並透過實時取得已下載的資料特性 \(** 16 kb、16 kb、16 kb…\) **取得到他覺得資料足夠後，會發起 Cancel 取消這個網路請求** （所以實際也不會拿完，除非檔案太小）。_ 
 

> _繼續播放後才會透過 Range 往後請求資料。_ 
 

> _（這部分跟我之前想的不一樣，我以為會是0–100、100–200\. \.這樣請求）_ 





**AVPlayer 請求範例：**
```
1. GET Range 0-1 => Response: 總長度 150000 / public.mp3 / true
2. GET 0-150000...
3. 16 kb receive
4. 16 kb receive...
5. cancel() // current offset is 700
6. 繼續播放
7. GET 700-150000...
8. 16 kb receive
9. 16 kb receive...
10. cancel() // current offset is 1500
11. 繼續播放
12. GET 1500-150000...
13. 16 kb receive
14. 16 kb receive...
16. If seek to...5000
17. cancel(12.) // current offset is 2000
18. GET 5000-150000...
19. 16 kb receive
20. 16 kb receive...
...
```


> _⚠️ **iOS ≤12 的情況下，會先發幾個較短的請求試著摸摸看（？然後才會發要求到總長度的請求； iOS ≥ 13 則會直接發要求到總長度的請求。**_ 





還有個題外的坑，就是在觀察怎麼拿資源的時候，我使用了 [mitmproxy](../46410aaada00/) 工具嗅探，結果發現它顯示有錯，會等到 response 全部回來才會顯示，而不是顯示分段、使用持久連接接續下載；害我嚇了一大跳！以為 iOS 很笨居然每次都要整個檔案回來！下次要用工具時要有保持一點懷疑 Orz
#### Cancel 發起的時機
1. 前面說到的第二次請求，請求從 0 開始 到總長度的資源，有足夠 Data 後會發起 Cancel 取消請求。
2. Seek 時會先發起 Cancel 取消先前的請求。



> _⚠️ 在 AVQueuePlayer 中切換到下一個資源、AVPlayer 更換播放資源時並不會發起 Cancel 取消前一首的請求。_ 




#### AVQueue Pre\-buffering

其實也是同樣呼叫 Resource Loader 處理，只是他要求的資料範圍會比較小。
### 實現

有了以上前導知識後我們來看實現 AVPlayer 本地 Cache 功能的原理方式。

就是之前有提到的 `AVAssetResourceLoaderDelegate` ，這個接口讓我們能 **自行實踐 Resource Loader** 給 Asset 用。

Resource Loader 實際就是個打工仔，播放器是要檔案資訊還是檔案資料，範圍哪裡都哪裡都是他告訴我們，我們去做就是。


> _看到有範例是一個 **Resource Loader 服務所有 AVURLAsset** ，我覺得是錯的，應該要一個 Resource Loader 服務一個 AVURLAsset，跟著 AVURLAsset 的生命週期，他本來就屬於 AVURLAsset。_ 





> _一個 Resource Loader 服務所有 AVURLAsset 在 AVQueuePlayer 上會變得非常複雜且難以管理。_ 




#### 進入自訂的 Resource Loader 的時機點

要注意的是不是實踐了自己的 Resource Loader 他就會理你，只有當系統無法辨識處理這個資源的時候，才會走你的 Resource Loader。

所以我們在將 URL 資源給予 AVURLAsset 之前要先將 Scheme 換成我們自訂的 Scheme，不能是 http/https… 這些系統能處理的 Scheme。
```
http://zhgchg.li/music.mp3 => cacheable://zhgchg.li/music.mp3
```
#### `AVAssetResourceLoaderDelegate`

**只有兩個方法需要實現：**
- func resourceLoader\( \_ resourceLoader: AVAssetResourceLoader, shouldWaitForLoadingOfRequestedResource **loadingRequest** : AVAssetResourceLoadingRequest\) \-> Bool :


此方法問我們能不能處理此資源，return true 能，return false 我們也不處理（unsupported url）。

我們能從 `loadingRequest` 取出要請求什麼（第一次請求檔案資訊還是請求資料，請求資料的話 Range 是多少到多少）；知道請求後我們自行發起請求去拿資料， **在這我們就能決定要發起 URLSession 還是從本地返回 Data** 。

另外也能在此做 Data 加解密操作，保護原始資料。
- func resourceLoader\( \_ resourceLoader: AVAssetResourceLoader, didCancel **loadingRequest** : AVAssetResourceLoadingRequest\) :


前述說到的 **Cancel 發起時機** 發起 Cancel 時…

我們可以在這去取消正在請求的 URLSession。


![](/assets/6ce488898003/1*widvJqzE-HtG32B-6ZiFhw.jpeg)

#### 本地 Cache 實現方式

Cache 的部分我直接使用 [PINCache](https://github.com/pinterest/PINCache){:target="_blank"} ，將 Cache 工作交由他處理，免去我們要處理 Cache 讀寫 DeadLock、清除 Cache LRU 策略 實作上的問題。


> **_️️⚠️️️️️️️️️️️OOM警告！_** 
 

> _因為這邊是針對音樂做 Cache 檔案大小頂多 10 MB 上下，所以才能使用 PINCache 作為本地 Cache 工具；如果是要服務影片就無法使用此方法（可能一次要載入好幾 GB 的資料到記憶體）_ 






■■■■■■■■■■■■■■ 
> **[Lex Tang](https://twitter.com/lexrus){:target="_blank"} @ Twitter Says:** 

> > @[zhgchgli](https://twitter.com/zhgchgli) 传统保守做法就是用 FileHandle，我写了大约 200 行 Swift 搞定这个事，它的 seek 和 read/write 能有效避免读写时的 OOM。之后 responds data request 的逻辑，可以参考 LeetCode 上 segment tree 相关的问题，如 [leetcode.com/problems/range…](https://leetcode.com/problems/range-module/) 

> **Tweeted at [2021-01-06 14:35:13](https://twitter.com/lexrus/status/1346827668860256258){:target="_blank"}.** 

■■■■■■■■■■■■■■ 


有這部分需求可參考大大的做法，用 FileHandle seek read/write 的特性進行處理。
### 開工！

不囉唆，先上完整專案：


[![](https://opengraph.githubassets.com/59fcb857c3e481a1e778c092409b7bd0d24f7f46f6aeccc55b1271b583f15f78/zhgchgli0718/resourceLoaderDemo)](https://github.com/zhgchgli0718/resourceLoaderDemo){:target="_blank"}

#### AssetData

本地 Cache 資料物件映射實現 NSCoding，因 PINCache 是依賴 archivedData 方法 encode/decode。
