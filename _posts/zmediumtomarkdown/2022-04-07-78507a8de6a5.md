---
title: Design Patterns 的實戰應用紀錄
author: ZhgChgLi
date: 2022-04-07T14:49:17.715+0000
last_modified_at: 2022-04-08T02:07:11.244+0000
categories: Pinkoi Engineering
tags: [ios-app-development,design-patterns,socketio,websocket,finite-state-machine]
description: 封裝 Socket.IO Client Library 需求時遇到的問題場景及解決方法應用到的 Design Patterns
image:
  path: assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg
render_with_liquid: false
---

### Design Patterns 的實戰應用紀錄

封裝 Socket\.IO Client Library 需求時遇到的問題場景及解決方法應用到的 Design Patterns


![Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg)

Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### 前言

此篇文章是真實的需求開發，所運用到 Design Pattern 解決問題的場景記錄；內容篇幅會涵蓋需求背景、實際遇到的問題場景 \(What?\)、為何要套用 Pattern 解決問題 \(Why?\)、實作上如何使用 \(How?\)，建議可以從頭閱讀會比較有連貫性。


> _本文會介紹四個開發此需求遇到的場景及七個解決此場景的 Design Patterns 應用。_ 




### 背景
#### 組織架構

敝司於今年拆分出 Feature Teams \(multiple\) 與 Platform Team；前者不必多說主要負責使用者端需求、Platform Team 這邊則面對的是公司內部的成員，其中一個工作項目就是技術引入、基礎建設及做好系統性整合，為 Feature Teams 開發需求時先鋒鋪好道路。
#### 當前需求

Feature Teams 要將原本的訊息功能 \(進頁面打 API 拿訊息資料，要更新最新訊息只能重整\) 改為 即時通訊 \(能即時收到最新訊息、對傳訊息\)。
#### Platform Team 工作

Platform Team 著重的點不只是當下的即時通訊需求，而是長遠的建設與複用性；評估後 webSocket 雙向通訊的機制在現代 App 中是不可或缺，除了此次的需求之外，以後也有很多機會都會用到，加上人力資源許可，故投入協助設計開發介面。

**目標：**
- 封裝 Pinkoi Server Side 與 Socket\.IO 通訊、身份驗證邏輯
- 封裝 Socket\.IO 煩瑣操作，提供基於 Pinkoi 商業需求的可擴充及方便使用介面
- 統一雙平台介面 **\(Socket\.IO 的 Android 與 iOS Client Side Library 支援的功能及介面不相同\)**
- Feature 端無需了解 Socket\.IO 機制
- Feature 端無需管理複雜的連線狀態
- 未來有 webSocket 雙向通訊需求能直接使用


**時間及人力：**
- iOS & Android 各投入一位
- 開發時程：時程 3 週

#### 技術細節

Web & iOS & Android 三平台均會支援此 Feature；要引入 webSocket 雙向通訊協議來實現，後端預計直接使用 [Socket\.io](http://socket.io/){:target="_blank"} 服務。


> **_首先要說 Socket \!= WebSocket_** 





關於 Socket 與 WebSocket 及技術細節可參考以下兩篇文章：
- [Socket，Websocket，Socket\.io的差異](https://leesonhsu.blogspot.com/2018/07/socketwebsocketsocketio.html){:target="_blank"}
- [为什么不直接使用socket ,还要定义一个新的websocket 的呢？](https://github.com/onlyliuxin/coding2017/issues/497){:target="_blank"}


簡而言之：
```
Socket 是 TCP/UDP 傳輸層的抽象封裝介面，而 WebSocket 是應用層的傳輸協議。
Socket 與 WebSocket 的關係就像狗跟熱狗的關係一樣，沒有關係。
```


![](/assets/78507a8de6a5/1*MC_nQC382khMeWggLejWOA.jpeg)


Socket\.IO 是 Engine\.IO 的一層抽象操作封裝，Engine\.IO 則是對 WebSocket 的使用封裝，每層只負責對上對下之間的交流，不允許貫穿操作\(e\.g\. Socket\.IO 直接操作 WebSocket 連線\)。

Socket\.IO/Engine\.IO 除了基本的 WebSocket 連線外還實做了很多方便好用的功能集合\(e\.g\. 離線發送 Event 機制、類似 Http Request 機制、Room/Group 機制…等等\)。

Platform Team 這層的主要職責是橋接 Socket\.IO 與 Pinkoi Server Side 之間的邏輯，供應上層 Feature Teams 開發功能時使用。
#### [Socket\.IO Swift Client](https://github.com/socketio/socket.io-client-swift){:target="_blank"} 有坑
- 已許久未更新 \(最新一版還在 2019\)，不確定是否還有在維護。
- Client & Server Side Socket IO Version 要對齊，Server Side 可加上 `{allowEIO3: true}` / 或 Client Side 指定相同版本 `.version` 
否則怎麼連都連不上。
- 命名方式、介面與官網範例很多都對不起來。
- Socket\.io 官網範例都是拿 Web 做介紹，實際上 Swift Client **並不一定有全支援官網寫的功能** 。
此次實作發現 iOS 這邊 Library 並未實現離線發送 Event 機制
\(我們是自行實現的，請往後繼續閱讀\)



> **_建議有要採用 Socket\.IO 前先實驗看看你想要的機制是否支援。_** 
 

> _Socket\.IO Swift Client 是基於 **[Starscream](https://github.com/daltoniam/Starscream){:target="_blank"}** WebSocket Library 的封裝，必要時可降級使用 Starscream。_ 




```
背景資訊補充到此結束，接下來進入正題。
```
### Design Patterns

設計模式說穿了就只是軟體設計當中常見問題的解決方案，不一定要用設計模式才能開發、設計模式不一定能適用所有場景、也沒人說不能自行歸納出新的設計模式。


![[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}](/assets/78507a8de6a5/1*MAm5WPynbv7M9tdmW2lNGQ.jpeg)

[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}

但現有的設計模式 \(The 23 Gang of Four Design Patterns\) 已是軟體設計中的共同知識，只要提到 XXX Pattern 大家腦中就會有相應的架構藍圖，不需多做解釋、後續維護也比較好知道脈絡、且已是經過業界驗證的方法不太需要花時間審視物件依賴問題；在適合的場景選用適合的模式可以降低溝通及維護成本，提升開發效率。


> **_設計模式可以組合使用，但不建議對現有設計模式魔改、強行為套用而套用、套用不符合分類的 Pattern \(e\.g\. 用責任練模式來產生物件\)，會失去使用的意義更可能造成後續接手的人的誤會。_** 




#### 本篇會提到的 Design Patterns：
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}
- [Flywieght Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}
- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}
- [Finite\-State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"} \+ [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}
- [Chain Of Resposibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}
- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}


會逐一在後面解釋什麼場境用了、為何要用。


> _本文著重在 Design Pattern 的應用，而非 Socket\.IO 的操作，部分示例會因為描述方便而有所刪減， **無法適用真實的 Socket\.IO 封裝** 。_ 





> _因篇幅有限，本文不會詳細介紹每個設計模式的架構，請先點各個模式的連結進入了解該模式的架構後再繼續閱讀。_ 





> _Demo Code 會使用 Swift 撰寫。_ 




### 需求場景 1\.
#### What?
- 使用相同的 Path 在不同頁面、Object 請求 Connection 時能複用取得相同的物件。
- Connection 需為抽象介面，不直接依賴 Socket\.IO Object

#### Why?
- 減少記憶體開銷及重複連線的時間、流量成本。
- 為未來抽換成其他框架預留空間

#### How?
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"} ：創建型 Pattern，保證一個物件只會有一個實體。
- [Flywieght Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"} ：結構型 Pattern，基於共享多個物件相同的狀態，重複使用。
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"} ：創建型 Pattern，抽象物件產生方法，使其能在外部抽換。


**實際案例使用：**


![](/assets/78507a8de6a5/1*flQa_EfErGBwbmEwpI7ZgQ.png)

- **Singleton Pattern：** `ConnectionManager` 在 App Lifecycle 中僅存在一個的物件，用來管理 `Connection` 取用操作。
- **Flywieght Pattern：** `ConnectionPool` 顧名思義就是 Connection 的共用池子，統一從這個池子的方法拿出 Connection，其中邏輯就會包含當發現 URL Path 一樣時直接給予已經在池子裡的 Connection。
`ConnectionHandler` 則做為 `Connection` 的外在操作、狀態管理器。
- **Factory Pattern：** `ConnectionFactory` 搭配上面 Flywieght Pattern 當發現池子沒有可複用的 `Connection` 時則用此工廠介面去產生。

